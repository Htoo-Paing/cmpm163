<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Lab 7: Mesh Manipulation</title>
        <style>
            body { margin: 0; }
            canvas { display: block; }
        </style>
    </head>
    <body>
        <script src="../three.js-master/build/three.js"></script>
        <script src="../three.js-master/examples/js/loaders/GLTFLoader.js"></script>
        <script src="../three.js-master/examples/js/utils/MathUtils.js"></script>
        <script id="vertexShader" type="x-shader/x-vertex">
            // code for vertex shader
            uniform sampler2D heightMap1;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vec4 heightColor = texture2D(heightMap1, uv);
                vec3 newPosition = position + normal * heightColor.r * 4.0 * heightColor.r;
                vec4 modelViewPosition = modelViewMatrix * vec4(newPosition, 1.0);
                gl_Position = projectionMatrix * modelViewPosition;
            }
        </script>

        <script id="fragmentShader" type="x-shader/x-fragment">
            // code for fragment shader
            uniform sampler2D texture1;
            varying vec2 vUv;
            void main() {
                gl_FragColor = texture2D(texture1, vUv);
            }
        </script>
        <script>
            // setup the scene
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, 
                window.innerWidth/window.innerHeight, 0.1, 1000);
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera.position.y = 5;
            camera.position.z = 0;
            camera.rotation.x = -.5;

            const light = new THREE.DirectionalLight(0xffffff, 1.0);
            light.position.set(1,1,1).normalize();
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));

            //texture and height map
            var uniforms = {
                texture1: { type: "t", value:THREE.ImageUtils.loadTexture("textures/texture.jpg")},
                heightMap1: { type: "t",value:THREE.ImageUtils.loadTexture("textures/volcanoheightmap.png")}
            };

            var material = new THREE.ShaderMaterial({ uniforms: uniforms, 
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent});

            var plane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10, 200, 200), material);
            plane.position.z = -10;
            plane.position.y = -0.7;
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            //specular plane (water)
            const mat = new THREE.MeshPhongMaterial({color:0x2288ff, 
                Shininess:100, side:THREE.DoubleSide, opacity: 0.65, transparent: true})
            var p = new THREE.PlaneGeometry(10, 10, 200, 200);
            var plane2 = new THREE.Mesh(p, mat);
            plane2.position.z = -10;
            plane2.position.y = 0;
            plane2.rotation.x = -Math.PI / 2;
            scene.add(plane2);

            //wave shader
            var matShader;
            mat.onBeforeCompile = (shader) => {
                shader.uniforms.time = { value: 0}
                shader.vertexShader = `
                uniform float time;
            ` + shader.vertexShader

                const token = '#include <begin_vertex>'
                const customTransform = `
                    vec3 transformed = vec3(position);
                    float freq = 3.0;
                    float amp = 0.1;
                    float angle = (time + position.x + position.y * 0.5)*freq;
                    transformed.z += sin(angle)*amp;
                    objectNormal = normalize(vec3(-amp * freq * cos(angle),0.0,1.0));
                    vNormal = normalMatrix * objectNormal;
                `
                shader.vertexShader = shader.vertexShader.replace(token,customTransform)
                matShader = shader
            }

            //boat code
            var loader1 = new THREE.GLTFLoader();
            var boat;
            loader1.load('objects/woodboat.glb', function (gltf) {
                boat = gltf.scene;
                boat.position.x = 2;
                boat.position.z = -7;
                boat.rotation.y = -0.4;
                boat.rotation.x = THREE.MathUtils.degToRad(0);
                boat.scale.x = 0.25;
                boat.scale.y = 0.25;
                boat.scale.z = 0.25;

                scene.add(boat);
            }, function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded' );
            }, function (error) {
                console.error(error);
            });

            //bird code
            var loader2 = new THREE.GLTFLoader();
            var bird;
            loader1.load('objects/bird.glb', function (gltf) {
                bird = gltf.scene;
                bird.position.x = -2;
                bird.position.z = -7;
                bird.rotation.z = THREE.MathUtils.degToRad(45);
                bird.scale.x = 0.02;
                bird.scale.y = 0.02;
                bird.scale.z = 0.02;

                scene.add(bird);
            }, function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded' );
            }, function (error) {
                console.error(error);
            });

            function animate(time) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);

                if(matShader) matShader.uniforms.time.value = time/1000;
                
                if (boat) {
                    boat.position.set(2, (Math.sin((time + 600) / (1000 / 3)) * 0.1) + 0.22, -7);
                    boat.rotation.set((Math.sin((time + 600) / (1000 / 3)) * -0.1), (Math.sin(time/ 1000) * -0.05) + -0.4, 0);
                }
                if (bird) {
                    bird.position.set(Math.sin(THREE.MathUtils.degToRad(time / 15)) * 2.0,
                        3 + (Math.sin(THREE.MathUtils.degToRad(time / 25)) * 0.5),
                        (Math.cos(THREE.MathUtils.degToRad(time / 15)) * 2.0) - 10);
                    bird.rotation.set(0, ((time % 5400) * Math.PI * 2 / 5400) + (Math.PI / 2), 0);
                }
            }
            renderer.setAnimationLoop(animate)

        </script>
    </body>
</html>
